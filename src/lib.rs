// example from Msg
//

mod handler;
mod protocol;

pub use protocol::MsgContent;

use handler::Handler;
pub use handler::Success;
use libp2p::core::{connection::ConnectionId, PeerId};
use libp2p::swarm::{NetworkBehaviour, NetworkBehaviourAction, NotifyHandler, PollParameters};
use std::{
    collections::VecDeque,
    task::{Context, Poll},
};

use smallvec::SmallVec;
use std::collections::hash_map::HashMap;

#[deprecated(
    since = "0.30.0",
    note = "Use re-exports that omit `Msg` prefix, i.e.  etc"
)]
pub use self::{Event as StreamEvent, Result as StreamResult, Success as StreamSuccess};

#[deprecated(since = "0.30.0", note = "Use libp2p_chat::Behaviour instead.")]
use std::io::Error;
/// The result of an inbound or outbound stream.
pub type Result = std::result::Result<Success, Error>;

/// A [`NetworkBehaviour`] that responds to inbound pings and
/// periodically sends outbound pings on every established connection.
///
/// See the crate root documentation for more information.
pub struct Behaviour {
    /// Queue of events to yield to the swarm.
    events: VecDeque<NetworkBehaviourAction<Event, Handler>>,

    /// List of peers to send messages to.
    target_peers: HashMap<PeerId, SmallVec<[i32; 8]>>,
}

/// Event generated by the `Ping` network behaviour.
#[derive(Debug)]
pub struct Event {
    /// The peer ID of the remote.
    pub peer: PeerId,
    /// The result of an inbound or outbound ping.
    pub result: protocol::MsgContent,
}

impl Behaviour {
    /// Creates a new `Ping` network behaviour with the given configuration.
    pub fn new() -> Self {
        Self {
            events: VecDeque::new(),
            target_peers: HashMap::new(),
        }
    }

    pub fn send(&mut self, data: impl Into<Vec<u8>>) {
        let d = data.into();

        for peer in self.target_peers.keys() {
            self.events
                .push_back(NetworkBehaviourAction::NotifyHandler {
                    peer_id: *peer,
                    handler: NotifyHandler::Any,
                    event: protocol::MsgContent { data: d.clone() },
                });
        }
    }

    pub fn insert(&mut self, peer_id: &PeerId) {
        self.target_peers.insert(*peer_id, SmallVec::new());
    }

    pub fn remove(&mut self, peer_id: &PeerId) {
        self.target_peers.remove(peer_id);
    }
}

impl Default for Behaviour {
    fn default() -> Self {
        Self::new()
    }
}

impl NetworkBehaviour for Behaviour {
    type ConnectionHandler = Handler;
    type OutEvent = Event;

    fn new_handler(&mut self) -> Self::ConnectionHandler {
        Handler::new()
    }

    fn inject_event(&mut self, peer: PeerId, conn_id: ConnectionId, result: protocol::MsgContent) {
        println!("PeerId {:?},ConnId {:?}", peer, conn_id);
        self.events
            .push_front(NetworkBehaviourAction::GenerateEvent(Event {
                peer,
                result,
            }))
    }

    fn poll(
        &mut self,
        _: &mut Context<'_>,
        _: &mut impl PollParameters,
    ) -> Poll<NetworkBehaviourAction<Self::OutEvent, Self::ConnectionHandler>> {
        if let Some(e) = self.events.pop_back() {
            Poll::Ready(e)
        } else {
            Poll::Pending
        }
    }
}
